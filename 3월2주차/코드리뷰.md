간단히 세줄리뷰

## 🐣서정빈🐣 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
  1. 중복없는 조합을 구하는 재귀 구문 활용
  2. start를 term[day] 만큼 증가
  3. 기간이 날자의 크기를 초과하면 재귀 종료 후 
#### [연구소] <br>
  1. map을 입력받을때 빈곳의 좌표를 벡터에 받아 기록, 바이러스 위치도 다른 벡터에 기록
  2. 중복없는 조합을 이용하여 빈곳의 좌표 중 벽이 지어질 위치를 3군데 정함
  3. 해당 위치에 벽을 세우고 바이러스를 Flood-Fill을 활용하여 확산하고 빈곳을 
#### [로봇_청소기] <br>
  1. 기본적인 Flood-Fill 구조 활용
  2. 기본적인 Flood-Fill과 달리 방향배열을 통해 현재 기준 사방의 좌표를 queue에 넣지 않고 조건에 부합하는 상황이 발생하면 push후 상황종료
  3. 청소 할 때마다 청소 한 횟수를 저장하여   
#### [연산자_끼워넣기] <br>
  1. 기본 구조는 재귀함수 활용, 재귀함수 파라미터는 연산횟수와 결과값 사용
  2. 연산자배열이 0일때는 가지치기, 아닐때는 연산자배열어서 1씩 줄이고 각 인덱스 값에 따라 연산하여 재귀 진행
  3. 재귀 끝나고 나올때 연산자배열에 1을 더해 원래상태로 복구


## 🐒박현종🐒 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
  1. Top down 재귀 & memo 배열 
  2. memo[now]값이 0이 아닌 경우, 상담일자가 퇴사일을 넘어가는경우, now가 N보다 큰 경우 각각 다른 값 return
  3. 각 일자마다 상담O 또는 상담X 두 경우로 나눠 max값 리턴
#### [연구소] <br>
  1. map의 바이러스가 있는 좌표와 빈곳의 좌표를 각각 vector로 기록
  2. dfs - 재귀로 벽을 설치할 3곳 지정
  3. floodfill - map에 virus 채우고 0개수 확인 최대인 경우 저장
#### [로봇_청소기] <br>
  1. 구현, 시뮬레이션 - 좌표와 방향을 파라미터로 받는 함수 구현
  2. 4방향 확인 후 반시계방향부터 확인하며 이동가능한경우 이동 및 cnt++, 이동경로는 -1로 표시
  3. 이동 불가한 경우 계속 뒤로 이동하며 함수 재귀, 뒤가 1인경우 끝
#### [연산자_끼워넣기] <br>
  1. dfs 재귀, 파라미터는 재귀 lev, 현재까지 계산한 결과값, 모든 숫자를 사용하면 return
  2. 연산자 +-*/ 순서대로 갯수 배열에 저장 for문으로 순회하며 재귀
  3. 재귀 전에는 사용한 연산자의 갯수를 -1, 재귀가 끝난 후 다시 +1


## 🦕소세영🦕 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
  1. dfs 사용. 현재 day를 lev로, 합을 sum으로 받음, used 사용
  2. 끝나는 날이 퇴사 날을 넘어가면, 다음날로 넘어감
  3. 퇴사날에서 sum과 최대값 비교해서 마지막에 최대값 출력
#### [연구소] <br>
#### [로봇_청소기] <br>
#### [연산자_끼워넣기] <br>
  1. dfs로 (lev==연산자 개수)까지 path 저장
  2. 숫자 순서대로 for문 돌면서 path에 저장된 연산자로 계산
  3. 기존 최대보다 크면 max값 갱신, 기존 최소보다 작으면 mini값 갱신해서 출력
  

## 🏰이성연🏰 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
#### [연구소] <br>
#### [로봇_청소기] <br>
#### [연산자_끼워넣기] <br>


## 🏢한석현🏢 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
#### [연구소] <br>
#### [로봇_청소기] <br>
#### [연산자_끼워넣기] <br>


## 🐟이유경🐟 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
#### [연구소] <br>
#### [로봇_청소기] <br>
#### [연산자_끼워넣기] <br>


## 🐔이재명🐔 <br>
#### [테트로미노] <br>
  1. map을 90도 회전 180도 회전 270도 회전해서 각 각의 블럭을 대입.
  2. map을 대치이동 시킨 후 각 각의 블럭을 대입.
  3. 각 각의 상황에서 큰 값 구하기.
#### [퇴사] <br>
  1. 기본 구조는 재귀 활용, 재귀함수 파라미터는 누적기간과 결과값 사용.
  2. 기저 조건 : 연산횟수가 N이하면 max 계산 연산횟수가 N이상이면 리턴.
  3. 재귀를 선택힐 때와 선택 안할 때로 2가지를 이용.
#### [연구소] <br>
#### [로봇_청소기] <br>
  1. 방향 배열 반시계 방향으로 설정. 반복문 사용.
  2. 문제 조건에 맞게 조건문 작성
  3. 카운트++;
#### [연산자_끼워넣기] <br>
  1. 기본 구조는 재귀함수 활용, 재귀함수 파라미터는 연산횟수(=인덱스)와 연산자 갯수 4종류와 결과값 사용
  2. 기저 조건 : 연산횟수가 N이면 max와 min 계산 후 리턴. 연산자의 개수가 1이상일 떄만 재귀를 돈다.
  3. 재귀를 돌 때 연산횟수+1 , 결과값에 연산자 종류에 따른 연산 실행.


## 🦜정민서🦜 <br>
#### [테트로미노] <br>
#### [퇴사] <br>
#### [연구소] <br>
#### [로봇_청소기] <br>
#### [연산자_끼워넣기] <br>
